navicella nemica: 

           \./
           <x>
           /^\

navicella nemica di secondo livello:

           x-x
           | |         
           x-x

navicella alleata:

            /\ /
          >|x |>
            \/ \

amogus: ඩ (Unicode: U+0D9E)

comandi utili:
gnome-terminal --geometry=widthxheight+Xposition+Yposition
resize -s <rows> <columns>

IDEE:
- Strutturare il gioco avendo 3 livelli, in cui cambia l'hud del livello, al 3° livello dopo i nemici classici spawna un boss
- Creare un hud che dica il numero di vite, nemici rimanenti, timer della partita, creare paesaggio che dia senso di movimento
- Permettere all'utente di selezionare una difficoltà (maggiore velocità delle astronavi, possibilità di mettere numero custom di nemici lo vogliono i prof )
- I nemici dei livelli successivi (solo del 3°) usano bombe più grandi o sono più veloci
- Ogni volta che superi un livello recuperi una vita nelle difficoltà più alte
- Aggingere voce High score nel menù principale
- implementare ridimensionamento schermo dalle impostazioni
- implementare mini istruzioni di tutorial per come funziona il gioco
- implementare menù di pausa dentro al game (wait dei processi)

TODO:
- Creare vettore di pipe per gestire le navicelle nemiche. Questo vettore di pipe dev'essere passato in scrittura ad ogni navicella nemica (alieno)
  e in lettura al check collision
- Creare una pipe che gestisce il numero di processi attivi, quando checkCollision leggerà, terrà quest'informazione in locale salvando dentro delle variabili
  (creare struttura ad hoc). Il vettore di pipe dev'essere inizializzato prima di tutte le fork nel main
- appena checkCollision funziona dobbiamo levare la gestione del rimbalzo del bullet, nelle specifiche dice che ogni collisione o quando un oggetto esce dallo schermo
  deve essere gestito dal processo checkCollision, ciò implica che dobbiamo mettere la read e la write in ogni funzione, anche quelle figlie generatrici di oggetti.

COLLISIONI:
- ALLY    ->  ENEMY         (persa la partita)
              BOMB          (ally perde una vita e muore processo bomba)

- ENEMY   ->  BULLET        (enemy perde una vita e muore processo bullet)
              MURO_UP&DOWN  (rimbalzo)
              MURO_SX       (ally perde una vita)

- BULLET  ->  MURO_UP&DOWN  (rimbalzo)
              BOMB          (entrambi i processi muoiono)
              MURO_DX       (muore processo)

- BOMB    ->  MURO_SX       (muore processo)



clipboard:

Object allyShip, aliens[NUMBER_ENEMY_SHIPS], obj;
  pid_t bullets[NUMBER_BULLETS] = {PROCESS_RETURN_CHILD_PID};
  int i, pipeInAlien;
  Status status;
  Object entitiesActive[ENTITY_TYPES][MAX_ENTITY_ACTIVE+1];
  //entityArrayInitializer(entitiesActive);



  void mountain() {

    int x = 1, y = 1, i = -1, j = 0, k;

    char mountains[ROWS][COLS]={{"        /\\    *      "},
                                {"       /**\\       *  "},
                                {"   *  /****\\         "},
                                {"     /*/\\***\\        "},
                                {"    / /**\\   \\  /\\   "},
                                {"   / /    \\   \\/YY\\  "},
                                {" /\\ /YYYYYY\\   \\YYY\\ "},
                                {"/  \\YYYYYYYY\\YYY\\YYY\\"}};

    while(true){
        
        if(x > getmaxx(stdscr)-15){
            for(k=0;k<ROWS;k++){
                move(y+k,1);
                delch();
            }
        }
        
        
        if(i == COLS-1){
            i=0;
        } else {
            i++;
        }

        
        for(j=0;j<ROWS;j++){
            mvaddch(y+j, x, mountains[j][i]);
        }
        
        x++;

        usleep(200000);
        refresh();
    }
}